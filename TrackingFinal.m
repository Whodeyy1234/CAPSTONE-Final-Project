p%% Webcam Calibration
clc
clear
% Auto-generated by cameraCalibrator app on 14-Apr-2021
%-------------------------------------------------------
% Define images to process
imageFileNames = {'E:\School\GCHS\Senior Year 2020-2021\Capstone\Senior Project\Programming\Calibration Images\WIN_20210511_10_28_53_Pro.jpg',...
    'E:\School\GCHS\Senior Year 2020-2021\Capstone\Senior Project\Programming\Calibration Images\WIN_20210511_10_28_28_Pro.jpg',...
    'E:\School\GCHS\Senior Year 2020-2021\Capstone\Senior Project\Programming\Calibration Images\WIN_20210511_10_28_35_Pro.jpg',...
    'E:\School\GCHS\Senior Year 2020-2021\Capstone\Senior Project\Programming\Calibration Images\WIN_20210511_10_28_42_Pro.jpg',...
    'E:\School\GCHS\Senior Year 2020-2021\Capstone\Senior Project\Programming\Calibration Images\WIN_20210511_10_28_47_Pro.jpg'
    };
% Detect checkerboards in images
[imagePoints, boardSize, imagesUsed] = detectCheckerboardPoints(imageFileNames);
imageFileNames = imageFileNames(imagesUsed);

% Read the first image to obtain image size
originalImage = imread(imageFileNames{1});
[mrows, ncols, ~] = size(originalImage);

% Generate world coordinates of the corners of the squares
squareSize = 2;  % in units of 'centimeters'
worldPoints = generateCheckerboardPoints(boardSize, squareSize);

% Calibrate the camera using fisheye parameters
[cameraParams, imagesUsed, estimationErrors] = estimateFisheyeParameters(imagePoints, worldPoints, ...
    [mrows, ncols], ...
    'EstimateAlignment', false, ...
    'WorldUnits', 'centimeters');

%% Setup Webcam
cam = webcam('HD Web Camera');
cam.Resolution = '1920x1080';
preview(cam);
pause(8);

%% Live Action
yDistances = [];
xDistances = [];
while 1==1
    %% Take a Picture
    Im = cam.snapshot();
    Im = undistortFisheyeImage(Im,cameraParams.Intrinsics,'OutputView','same', 'ScaleFactor', 10);
    Im = Im(230:880,360:1460,:);

    %% Thresholding the RED, Green, and BLUE Layers of the Image
    IRed = Im(:,:,1);
    IGreen = Im(:,:,2);
    IBlue = Im(:,:,3);

    %% Binarize Your Image
    levelr = 0.753;
    levelg = 0.375; 
    levelb = 0.325;

    ThrRed = imbinarize(IRed, levelr);
    ThrGreen = imbinarize(IGreen, levelg);
    ThrBlue = imbinarize(IBlue, levelb);

    BW_Image1 = ThrRed;
    BW_Image2 = ~ThrGreen;
    BW_Image3 = ~ThrBlue;
    BW_Image = logical(BW_Image3);
    BW_Conv = bwconvhull(~BW_Image);
    BW_Image = BW_Image & BW_Conv;

    %subplot(1,2,1),imshow(BW_Image);
    %title('Binarized Red Plane');
    %subplot(1,2,2),imshow(Im);
    %title('Original');

    %% Bounding Boxes
    bboxes = regionprops(BW_Image,'BoundingBox','Centroid');

    LowThresh = 30;
    HighThresh = 185;

    for k = 1:length(bboxes)
        CurrBB = bboxes(k).BoundingBox;
        CurrBBLen = CurrBB(4);
        CurrBBWid = CurrBB(3);
        if((CurrBBLen > LowThresh) && (CurrBBLen < HighThresh) && (CurrBBWid > LowThresh) && (CurrBBWid < HighThresh))
            bboxes(k).isBall = 1;
        else
            bboxes(k).isBall = 0;
        end
    end

    Balls = {};
    Centroids = {};
    indexes = [];
    for k = 1:length(bboxes)
        if(bboxes(k).isBall == 1)
            Ball = bboxes(k).BoundingBox;
            Centroid = bboxes(k).Centroid;
            Centroids = [Centroids Centroid];
            Balls = [Balls Ball];
            indexes = [indexes k];
        end
    end

    hold on
    for k = 1:length(bboxes)
        arrayfun(@(i)rectangle('Position',bboxes(k).BoundingBox(i,:),'EdgeColor','r'), find(bboxes(k).isBall)); 
    end
    hold off

    %% Determining Distances
    try
        LowThresh = 30;
        HighThresh = 70;
        CurrBB = Balls{1};
        CurrBBLen = CurrBB(4);
        CurrBBWid = CurrBB(3);
        if((CurrBBLen > LowThresh) && (CurrBBLen < HighThresh) && (CurrBBWid > LowThresh) && (CurrBBWid < HighThresh))
            CurrCentroid = Centroids{2};
            RobotX = CurrCentroid(1);
            RobotY = CurrCentroid(2);
            CurrCentroid = Centroids{1};
            BallX = CurrCentroid(1);
            BallY = CurrCentroid(2);
            XDistanceCm = (RobotX - BallX) * 7/100;
            YDistanceCm = (RobotY - BallY) * 7/100;
        else
            CurrCentroid = Centroids{1};
            RobotX = CurrCentroid(1);
            RobotY = CurrCentroid(2);
            CurrCentroid = Centroids{2};
            BallX = CurrCentroid(1);
            BallY = CurrCentroid(2);
            XDistanceCm = (RobotX - BallX) * 7/100;
            YDistanceCm = (RobotY - BallY) * 7/100;
        end

        %% Show the Image and Label with Distance
        imshow(Im);
        hold on
        for k = 1:length(bboxes)
            arrayfun(@(i)rectangle('Position',bboxes(k).BoundingBox(i,:),'EdgeColor','r'), find(bboxes(k).isBall)); 
        end
        hold off
        if(YDistanceCm < 0 && XDistanceCm < 0)
            title(['Move Down ',num2str(-YDistanceCm),' Cm; Move Right ',num2str(-XDistanceCm),' Cm']);
        elseif(YDistanceCm > 0 && XDistanceCm > 0)
            title(['Move Up ',num2str(YDistanceCm),' Cm; Move Left ',num2str(XDistanceCm),' Cm']);
        elseif(YDistanceCm > 0 && XDistanceCm < 0)
            title(['Move Up ',num2str(YDistanceCm),' Cm; Move Right ',num2str(-XDistanceCm),' Cm']);
        elseif (YDistanceCm < 0 && XDistanceCm > 0)
            title(['Move Down ',num2str(-YDistanceCm),' Cm; Move Left ',num2str(XDistanceCm),' Cm']);
        end
    catch
        title('No Balls Detected');
    end
end